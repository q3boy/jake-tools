// Generated by CoffeeScript 1.4.0
var coffee, color, colorMap, coverage, cs, error, fileDelete, fs, glob, httpGet, isDir, jade, jscover, jscoverage, list, listCopy, listDelete, mkdir, mkdirp, mocha, packageJson, path, print, request, run, short, spawn, testReport, testResult, treeDelete, us, yaml,
  __slice = [].slice;

fs = require('fs');

path = require('path');

cs = require('coffee-script');

jade = require("jade");

mkdirp = require("mkdirp").sync;

glob = require("glob");

us = require('underscore');

request = require('request');

jscover = require('jscover');

yaml = require('yamljs');

spawn = require('child_process').spawn;

colorMap = {
  black: 30,
  red: 31,
  green: 32,
  yellow: 33,
  blue: 34,
  magenta: 35,
  cyan: 36,
  white: 37
};

color = function(text, color) {
  if (color == null) {
    color = "green";
  }
  return "\x1B[" + colorMap[color] + "m" + text + "\x1B[0m";
};

print = function() {
  var args, name;
  name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  process.stdout.write("--------======== " + (color(name, "cyan")) + " ========--------\n");
  if (args.length > 0) {
    console.log.apply(console, args);
  }
};

error = function() {
  var args, name;
  name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  process.stderr.write("--------======== " + (color("ERROR: " + name, "red")) + " ========--------\n");
  if (args.length > 0) {
    console.error.apply(console, args);
  }
};

fileDelete = function(p) {
  if (p[0] !== '/') {
    p = path.join(process.cwd(), p);
  }
  try {
    return fs.unlinkSync(p);
  } catch (e) {

  }
};

list = function(includes, excludes) {
  var exclude, include, l, _i, _j, _len, _len1;
  l = [];
  if (typeof includes === 'string') {
    includes = [includes];
  }
  if (!excludes) {
    excludes = [];
  }
  if (typeof excludes === 'string') {
    excludes = [excludes];
  }
  for (_i = 0, _len = includes.length; _i < _len; _i++) {
    include = includes[_i];
    l = l.concat(glob.sync(include));
  }
  for (_j = 0, _len1 = excludes.length; _j < _len1; _j++) {
    exclude = excludes[_j];
    l = us.difference(l, glob.sync(exclude));
  }
  return us.uniq(l).map(function(p) {
    return path.relative(process.cwd(), p);
  });
};

run = function(cmd, cb, instantPrint) {
  var err, exec, out;
  if (instantPrint == null) {
    instantPrint = true;
  }
  cmd = cmd.split(' ');
  exec = spawn(cmd[0], cmd.slice(1), {
    stdio: ['ignore', 'pipe', 'pipe']
  });
  out = [];
  err = [];
  exec.stdout.on('data', function(data) {
    if (instantPrint) {
      return process.stdout.write(data);
    } else {
      return out.push(data);
    }
  });
  exec.stderr.on('data', function(data) {
    console.log(data.toString());
    if (instantPrint) {
      return process.stderr.write(data);
    } else {
      return err.push(data);
    }
  });
  if (cb != null) {
    return exec.on('exit', function(code) {
      if (code > 1) {
        error('Run cmd', cmd.join(' ') + '\n');
      }
      if (instantPrint) {
        return cb(code);
      } else {
        return cb(code, out, err);
      }
    });
  }
};

httpGet = function(url, file, cb) {
  request(url, function(err, resp, body) {
    if (err) {
      console.log("" + (color("http get")) + ": \"" + url + "\"");
      return cb(err);
    } else {
      console.log("" + (color("http get")) + ": \"" + (short(file)) + "\"");
      fs.writeFileSync(file, body);
      return cb;
    }
  });
};

short = function(p, fix) {
  if (fix == null) {
    fix = '';
  }
  return p.replace(path.join(process.cwd(), fix) + '/', '');
};

coffee = function(includes, excludes) {
  var content, file, l, target, _i, _len;
  l = list(includes, excludes);
  for (_i = 0, _len = l.length; _i < _len; _i++) {
    file = l[_i];
    target = path.join(path.dirname(file), "" + (path.basename(file, '.coffee')) + ".js");
    content = fs.readFileSync(file).toString();
    content = cs.compile(content, {
      bare: true
    });
    fs.writeFileSync(target, content);
    console.log("" + (color("coffee")) + ": \"" + (short(file)) + "\" => \"" + target + "\"");
  }
};

mocha = function(includes, excludes, report, cb) {
  var cmd, l;
  if (report == null) {
    report = 'spec';
  }
  l = list(includes, excludes);
  print("Run Mocha Tests");
  cmd = "" + __dirname + "/node_modules/.bin/mocha --compilers coffee:coffee-script --colors --reporter " + report + " " + (l.join(' '));
  if (cb != null) {
    return run(cmd, cb);
  } else {
    return run(cmd);
  }
};

packageJson = function() {
  if (fs.existsSync('package.yaml')) {
    fs.writeFileSync('package.json', JSON.stringify(yaml.parse(fs.readFileSync('package.yaml').toString().trim()), null, 2));
  }
};

jscoverage = function(dir, cb) {
  var tmp;
  tmp = dir + '.__tmp';
  fs.renameSync(dir, tmp);
  return jscover(tmp, dir, null, function(err, stdout) {
    treeDelete(tmp);
    console.log("" + (color("jscoverage")) + ": \"" + (short(dir)) + "\"");
    return cb();
  });
};

coverage = function(dirs, includes, excludes, cb) {
  var dir, flag, _i, _len, _results;
  if (typeof dirs === 'string') {
    dirs = [dirs];
  }
  flag = dirs.length;
  _results = [];
  for (_i = 0, _len = dirs.length; _i < _len; _i++) {
    dir = dirs[_i];
    _results.push(jscoverage(dir, function() {
      var cmd, l;
      if (--flag === 0) {
        l = list(includes, excludes);
        cmd = __dirname + ("/node_modules/.bin/mocha --colors --reporter json-cov " + (l.join(' ')));
        return run(cmd, function(code, outs, errs) {
          var buf, file, out, p, report, size, _j, _k, _l, _len1, _len2, _len3, _ref;
          size = 0;
          for (_j = 0, _len1 = outs.length; _j < _len1; _j++) {
            out = outs[_j];
            size += out.length;
          }
          buf = new Buffer(size);
          p = 0;
          for (_k = 0, _len2 = outs.length; _k < _len2; _k++) {
            out = outs[_k];
            p += out.copy(buf, p);
          }
          report = JSON.parse(buf.toString());
          _ref = report.files;
          for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
            file = _ref[_l];
            file.filename = short(file.filename);
          }
          return cb(code, report);
        }, false);
      }
    }));
  }
  return _results;
};

testResult = function(json) {
  var file, test, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
  if (json.failures.length === 0) {
    print("All " + json.passes.length + " Tests Passed");
  } else {
    error("" + json.failures.length + " Tests failures, " + json.passes.length + " Tests Passed");
    _ref = json.failures;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      test = _ref[_i];
      console.log("" + (color('failure', 'red')) + ": " + test.fullTitle);
    }
  }
  _ref1 = json.passes;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    test = _ref1[_j];
    console.log("" + (color('pass', 'green')) + ": " + test.fullTitle);
  }
  print("Code Coverage: " + (Math.round(json.coverage * 100) / 100) + "%");
  _ref2 = json.files;
  _results = [];
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    file = _ref2[_k];
    _results.push(console.log("" + (color(file.filename)) + ": " + (Math.round(file.coverage * 100) / 100) + "%"));
  }
  return _results;
};

testReport = function(name, data, tpl, file) {
  data = {
    data: data,
    name: name
  };
  if (arguments.length === 3) {
    file = tpl;
    tpl = __dirname + '/report/report.jade';
  }
  return fs.writeFileSync(file, jade.compile(fs.readFileSync(tpl), {
    filename: tpl,
    pretty: false
  })(data));
};

treeDelete = function(p) {
  var file, files, p1, _i, _len;
  try {
    if (p[0] !== '/') {
      p = path.join(process.cwd(), p);
    }
    if (!isDir(p)) {
      return;
    }
    files = fs.readdirSync(p);
    if (!files.length) {
      fs.rmdirSync(p);
      console.log("" + (color("rmdir")) + ": \"" + (short(p)) + "\"");
    } else {
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        p1 = path.join(p, file);
        if (isDir(p1)) {
          treeDelete(p1);
        } else {
          fs.unlinkSync(p1);
          console.log("" + (color("delete")) + ": \"" + (short(p1)) + "\"");
        }
      }
    }
    fs.rmdirSync(p);
    console.log("" + (color("rmdir")) + ": \"" + (short(p)) + "\"");
  } catch (e) {

  }
};

isDir = function(p) {
  return fs.existsSync(p) && fs.statSync(p).isDirectory();
};

mkdir = function(p, mode) {
  if (mode == null) {
    mode = "0755";
  }
  if (fs.existsSync(p)) {
    if (!isDir(p)) {
      throw Error("Destination is not a directory (" + to + "}.");
    }
  } else {
    mkdirp(p, mode);
    return console.log("" + (color("mkdir")) + ": \"" + (short(p)) + "\"");
  }
};

listCopy = function(to, includes, excludes) {
  var file, l, toFile, _i, _len;
  if (to[0] !== '/') {
    to = path.join(process.cwd(), to);
  }
  mkdir(to);
  if (!fs.existsSync(to)) {
    mkdirp(to, '0755');
    console.log("" + (color("mkdir")) + ": \"" + (short(to)) + "\"");
  } else {
    if (!isDir(to)) {
      throw Error("Destination is not a directory (" + (short(to)) + "}.");
    }
  }
  l = list(includes, excludes);
  for (_i = 0, _len = l.length; _i < _len; _i++) {
    file = l[_i];
    toFile = path.join(to, file);
    if (isDir(file)) {
      mkdir(toFile);
    } else {
      mkdir(path.dirname(toFile));
      fs.linkSync(file, toFile);
      console.log("" + (color("copy")) + ": \"" + (short(file)) + "\" => \"" + (short(toFile)) + "\"");
    }
  }
};

listDelete = function(includes, excludes) {
  var file, l, _i, _len;
  l = list(includes, excludes);
  for (_i = 0, _len = l.length; _i < _len; _i++) {
    file = l[_i];
    if (!isDir(file)) {
      fs.unlinkSync(file);
      console.log("" + (color("delete")) + ": \"" + (short(file)) + "\"");
    }
  }
};

exports.run = run;

exports.httpGet = httpGet;

exports.mocha = mocha;

exports.coverage = coverage;

exports.testResult = testResult;

exports.testReport = testReport;

exports.coffee = coffee;

exports.packageJson = packageJson;

exports.print = print;

exports.error = error;

exports.list = list;

exports.mkdirp = mkdirp;

exports.listCopy = listCopy;

exports.treeDelete = treeDelete;

exports.listDelete = listDelete;
